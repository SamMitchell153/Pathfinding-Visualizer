{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar.js","PathfindingVisualizer/RangeSlider.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","aStar","distanceToEnd","Math","sqrt","pow","setNodesDistanceToEnd","Horizontal","context","handleChange","value","setState","callbackFromParent","state","Row","Col","xs","min","max","onChange","Vertical","orientation","reverse","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","totalRows","totalCols","PathfindingVisualizer","updateRows","updatedRows","floor","updateCols","updatedCols","ceil","mouseIsPressed","selectedAlgorithm","cols","rows","getInitialGrid","document","title","getElementsByClassName","newGrid","getNewGridWithWallToggled","i","setTimeout","animateShortestPath","getElementById","visualizeDijkstra","console","log","visualizeAStar","animate","window","location","reload","Navbar","bg","expand","Brand","href","Toggle","aria-controls","Collapse","Nav","NavDropdown","Header","Item","onClick","Divider","Button","visualize","reset","Container","componentDidMount","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.17bfd516.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n\trender() {\r\n\t\tconst {\r\n\t\t\tcol,\r\n\t\t\tisFinish,\r\n\t\t\tisStart,\r\n\t\t\tisWall,\r\n\t\t\tonMouseDown,\r\n\t\t\tonMouseEnter,\r\n\t\t\tonMouseUp,\r\n\t\t\trow\r\n\t\t} = this.props;\r\n\t\tconst extraClassName = isFinish\r\n\t\t\t? \"node-finish\"\r\n\t\t\t: isStart\r\n\t\t\t? \"node-start\"\r\n\t\t\t: isWall\r\n\t\t\t? \"node-wall\"\r\n\t\t\t: \"\";\r\n\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tid={`node-${row}-${col}`}\r\n\t\t\t\tclassName={`node ${extraClassName}`}\r\n\t\t\t\tonMouseDown={() => onMouseDown(row, col)}\r\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, col)}\r\n\t\t\t\tonMouseUp={() => onMouseUp()}\r\n\t\t\t></div>\r\n\t\t);\r\n\t}\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n\tconst visitedNodesInOrder = [];\r\n\tstartNode.distance = 0;\r\n\tconst unvisitedNodes = getAllNodes(grid);\r\n\twhile (!!unvisitedNodes.length) {\r\n\t\tsortNodesByDistance(unvisitedNodes);\r\n\t\tconst closestNode = unvisitedNodes.shift();\r\n\t\t// If we encounter a wall, we skip it.\r\n\t\tif (closestNode.isWall) continue;\r\n\t\t// If the closest node is at a distance of infinity,\r\n\t\t// we must be trapped and should therefore stop.\r\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\t\tclosestNode.isVisited = true;\r\n\t\tvisitedNodesInOrder.push(closestNode);\r\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\r\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\r\n\t}\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n\tunvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\tfor (const neighbor of unvisitedNeighbors) {\r\n\t\tneighbor.distance = node.distance + 1;\r\n\t\tneighbor.previousNode = node;\r\n\t}\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n\tconst neighbors = [];\r\n\tconst { col, row } = node;\r\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\r\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\r\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\treturn neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n\tconst nodes = [];\r\n\tfor (const row of grid) {\r\n\t\tfor (const node of row) {\r\n\t\t\tnodes.push(node);\r\n\t\t}\r\n\t}\r\n\treturn nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\tconst nodesInShortestPathOrder = [];\r\n\tlet currentNode = finishNode;\r\n\twhile (currentNode !== null) {\r\n\t\tnodesInShortestPathOrder.unshift(currentNode);\r\n\t\tcurrentNode = currentNode.previousNode;\r\n\t}\r\n\treturn nodesInShortestPathOrder;\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function aStar(grid, startNode, finishNode) {\r\n\tconst visitedNodesInOrder = [];\r\n\tstartNode.distance = 0;\r\n\tsetNodesDistanceToEnd(grid, finishNode);\r\n\tconst unvisitedNodes = getAllNodes(grid);\r\n\twhile (!!unvisitedNodes.length) {\r\n\t\tsortNodesByDistance(unvisitedNodes);\r\n\t\tconst closestNode = unvisitedNodes.shift();\r\n\t\t// If we encounter a wall, we skip it.\r\n\t\tif (closestNode.isWall) continue;\r\n\t\t// If the closest node is at a distance of infinity,\r\n\t\t// we must be trapped and should therefore stop.\r\n\t\tif (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n\t\tclosestNode.isVisited = true;\r\n\t\tvisitedNodesInOrder.push(closestNode);\r\n\t\tif (closestNode === finishNode) return visitedNodesInOrder;\r\n\t\tupdateUnvisitedNeighbors(closestNode, grid);\r\n\t}\r\n}\r\n\r\nfunction setNodesDistanceToEnd(grid, finishNode) {\r\n\t//set distance to end with euclidean distance\r\n\tfor (const row of grid) {\r\n\t\tfor (const currentNode of row) {\r\n\t\t\tcurrentNode.distanceToEnd = Math.sqrt(\r\n\t\t\t\tMath.pow(currentNode.col - finishNode.col, 2) +\r\n\t\t\t\t\tMath.pow(currentNode.row - finishNode.row, 2)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n\tunvisitedNodes.sort(\r\n\t\t(nodeA, nodeB) =>\r\n\t\t\tnodeA.distance +\r\n\t\t\tnodeA.distanceToEnd -\r\n\t\t\t(nodeB.distance + nodeB.distanceToEnd)\r\n\t);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n\tconst unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\tfor (const neighbor of unvisitedNeighbors) {\r\n\t\tneighbor.distance = node.distance + 1;\r\n\t\tneighbor.previousNode = node;\r\n\t}\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n\tconst neighbors = [];\r\n\tconst { col, row } = node;\r\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\r\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\r\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\treturn neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n\tconst nodes = [];\r\n\tfor (const row of grid) {\r\n\t\tfor (const node of row) {\r\n\t\t\tnodes.push(node);\r\n\t\t}\r\n\t}\r\n\treturn nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\tconst nodesInShortestPathOrder = [];\r\n\tlet currentNode = finishNode;\r\n\twhile (currentNode !== null) {\r\n\t\tnodesInShortestPathOrder.unshift(currentNode);\r\n\t\tcurrentNode = currentNode.previousNode;\r\n\t}\r\n\treturn nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Slider from \"react-rangeslider\";\r\n\r\nimport { Col, Row } from \"react-bootstrap\";\r\n\r\nclass Horizontal extends Component {\r\n\tconstructor(props, context) {\r\n\t\tsuper(props, context);\r\n\t\tthis.state = {\r\n\t\t\tvalue: 30\r\n\t\t};\r\n\t}\r\n\r\n\thandleChange = value => {\r\n\t\tthis.setState({\r\n\t\t\tvalue: value\r\n\t\t});\r\n\t\tthis.props.callbackFromParent(value);\r\n\t};\r\n\r\n\trender() {\r\n\t\tlet { value } = this.state;\r\n\t\treturn (\r\n\t\t\t<Row className=\"slider\">\r\n\t\t\t\t<Col id=\"xValueLabel\" xs=\"1\">\r\n\t\t\t\t\t{value}\r\n\t\t\t\t</Col>\r\n\t\t\t\t<Col className=\"slider\" xs=\"11\">\r\n\t\t\t\t\t<Slider\r\n\t\t\t\t\t\tmin={10}\r\n\t\t\t\t\t\tmax={100}\r\n\t\t\t\t\t\tvalue={value}\r\n\t\t\t\t\t\tonChange={this.handleChange}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</Col>\r\n\t\t\t</Row>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass Vertical extends Component {\r\n\tconstructor(props, context) {\r\n\t\tsuper(props, context);\r\n\t\tthis.state = {\r\n\t\t\tvalue: 25\r\n\t\t};\r\n\t}\r\n\r\n\thandleChange = value => {\r\n\t\tthis.setState({\r\n\t\t\tvalue: value\r\n\t\t});\r\n\t\tthis.props.callbackFromParent(value);\r\n\t};\r\n\trender() {\r\n\t\tconst { value } = this.state;\r\n\t\treturn (\r\n\t\t\t<div className=\"slider orientation-reversed\">\r\n\t\t\t\t<div className=\"slider-vertical\">\r\n\t\t\t\t\t<div id=\"yValueLabel\">{value}</div>\r\n\t\t\t\t\t<Slider\r\n\t\t\t\t\t\tmin={10}\r\n\t\t\t\t\t\tmax={50}\r\n\t\t\t\t\t\tvalue={value}\r\n\t\t\t\t\t\torientation=\"vertical\"\r\n\t\t\t\t\t\treverse={true}\r\n\t\t\t\t\t\tonChange={this.handleChange}\r\n\t\t\t\t\t/>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport { Horizontal, Vertical };\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\n\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport { aStar } from \"../algorithms/astar\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nimport {\r\n\tContainer,\r\n\tCol,\r\n\tRow,\r\n\tButton,\r\n\tNav,\r\n\tNavbar,\r\n\tNavDropdown\r\n} from \"react-bootstrap\";\r\n\r\nimport \"react-rangeslider/lib/index.css\";\r\n\r\nimport { Horizontal, Vertical } from \"./RangeSlider.jsx\";\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 5;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 25;\r\n\r\nlet totalRows = 20;\r\nlet totalCols = 30;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.state = {\r\n\t\t\tgrid: [],\r\n\t\t\tmouseIsPressed: false,\r\n\t\t\tselectedAlgorithm: \"None\",\r\n\t\t\tcols: 25,\r\n\t\t\trows: 30\r\n\t\t};\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tconst grid = getInitialGrid();\r\n\t\tthis.setState({ grid });\r\n\t\tdocument.title = \"Pathfinding Visualiser\";\r\n\r\n\t\tif (totalCols > 40) {\r\n\t\t\tdocument.getElementsByClassName(\"grid\")[0].className = \"grid halfSize\";\r\n\t\t} else {\r\n\t\t\tdocument.getElementsByClassName(\"grid\")[0].className = \"grid\";\r\n\t\t}\r\n\t}\r\n\r\n\thandleMouseDown(row, col) {\r\n\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n\t\tthis.setState({ grid: newGrid, mouseIsPressed: true });\r\n\t}\r\n\r\n\thandleMouseEnter(row, col) {\r\n\t\tif (!this.state.mouseIsPressed) return;\r\n\t\tconst newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n\t\tthis.setState({ grid: newGrid });\r\n\t}\r\n\r\n\thandleMouseUp() {\r\n\t\tthis.setState({ mouseIsPressed: false });\r\n\t}\r\n\r\n\tanimate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n\t\tfor (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n\t\t\tif (i === visitedNodesInOrder.length) {\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tthis.animateShortestPath(nodesInShortestPathOrder);\r\n\t\t\t\t}, 10 * i);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tconst node = visitedNodesInOrder[i];\r\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className +=\r\n\t\t\t\t\t\" node-visited\";\r\n\t\t\t}, 10 * i);\r\n\t\t}\r\n\t}\r\n\r\n\tanimateShortestPath(nodesInShortestPathOrder) {\r\n\t\tfor (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tconst node = nodesInShortestPathOrder[i];\r\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className +=\r\n\t\t\t\t\t\" node-shortest-path\";\r\n\t\t\t}, 50 * i);\r\n\t\t}\r\n\t}\r\n\r\n\tvisualize() {\r\n\t\tswitch (this.state.selectedAlgorithm) {\r\n\t\t\tcase \"Dijkstra\":\r\n\t\t\t\tthis.visualizeDijkstra();\r\n\t\t\t\tconsole.log(\"Visualizing Dijkstra\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"A*\":\r\n\t\t\t\tthis.visualizeAStar();\r\n\t\t\t\tconsole.log(\"Visualizing A*\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t// run error, no selected algorithm\r\n\t\t\t\tconsole.log(\"No Input selected\");\r\n\t\t}\r\n\t}\r\n\r\n\tvisualizeDijkstra() {\r\n\t\tconst { grid } = this.state;\r\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\t\tconst visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n\t\tthis.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\t}\r\n\r\n\tvisualizeAStar() {\r\n\t\tconst { grid } = this.state;\r\n\t\tconst startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n\t\tconst finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\t\tconst visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n\t\tconst nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n\t\tthis.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n\t}\r\n\r\n\treset() {\r\n\t\twindow.location.reload();\r\n\t}\r\n\r\n\tupdateRows = updatedRows => {\r\n\t\ttotalRows = updatedRows;\r\n\r\n\t\tSTART_NODE_ROW = Math.floor(updatedRows / 2);\r\n\t\tFINISH_NODE_ROW = Math.floor(updatedRows / 2);\r\n\t};\r\n\r\n\tupdateCols = updatedCols => {\r\n\t\ttotalCols = updatedCols;\r\n\t\tSTART_NODE_COL = Math.floor(updatedCols / 5);\r\n\t\tFINISH_NODE_COL = updatedCols - Math.ceil(updatedCols / 5);\r\n\t};\r\n\r\n\trender() {\r\n\t\tconst { grid, mouseIsPressed, selectedAlgorithm } = this.state;\r\n\r\n\t\treturn (\r\n\t\t\t<>\r\n\t\t\t\t<Navbar bg=\"light\" expand=\"lg\">\r\n\t\t\t\t\t<Navbar.Brand href=\"#home\"> Pathfinding Visualiser</Navbar.Brand>\r\n\t\t\t\t\t<Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n\t\t\t\t\t<Navbar.Collapse id=\"basic-navbar-nav\">\r\n\t\t\t\t\t\t<Nav className=\"mr-auto\">\r\n\t\t\t\t\t\t\t<NavDropdown title={\"Selected Algorithm: \" + selectedAlgorithm}>\r\n\t\t\t\t\t\t\t\t<NavDropdown.Header>Unweighted</NavDropdown.Header>\r\n\t\t\t\t\t\t\t\t<NavDropdown.Item\r\n\t\t\t\t\t\t\t\t\tonClick={() =>\r\n\t\t\t\t\t\t\t\t\t\tthis.setState({ selectedAlgorithm: \"Dijkstra\" })\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\t\tDijkstra\r\n\t\t\t\t\t\t\t\t</NavDropdown.Item>\r\n\t\t\t\t\t\t\t\t<NavDropdown.Divider />\r\n\t\t\t\t\t\t\t\t<NavDropdown.Header>Weighted</NavDropdown.Header>\r\n\t\t\t\t\t\t\t\t<NavDropdown.Item\r\n\t\t\t\t\t\t\t\t\tonClick={() => this.setState({ selectedAlgorithm: \"A*\" })}\r\n\t\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\t\tA*\r\n\t\t\t\t\t\t\t\t</NavDropdown.Item>\r\n\t\t\t\t\t\t\t</NavDropdown>\r\n\t\t\t\t\t\t</Nav>\r\n\t\t\t\t\t\t<Button onClick={() => this.visualize()}>Visualize</Button>\r\n\t\t\t\t\t\t<Button onClick={() => this.reset()}>Reset</Button>\r\n\t\t\t\t\t</Navbar.Collapse>\r\n\t\t\t\t</Navbar>\r\n\r\n\t\t\t\t<Container>\r\n\t\t\t\t\t<Row>\r\n\t\t\t\t\t\t<Col xs=\"1\">\r\n\t\t\t\t\t\t\t<Button onClick={() => this.componentDidMount()}>Update</Button>\r\n\t\t\t\t\t\t</Col>\r\n\t\t\t\t\t\t<Col xs=\"11\">\r\n\t\t\t\t\t\t\t<div className=\"gridXSlider\">\r\n\t\t\t\t\t\t\t\t<Horizontal\r\n\t\t\t\t\t\t\t\t\tid=\"XSlider\"\r\n\t\t\t\t\t\t\t\t\tcallbackFromParent={this.updateCols}\r\n\t\t\t\t\t\t\t\t></Horizontal>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</Col>\r\n\t\t\t\t\t</Row>\r\n\t\t\t\t\t<Row>\r\n\t\t\t\t\t\t<Col xs=\"1\">\r\n\t\t\t\t\t\t\t<div className=\"gridYSlider\">\r\n\t\t\t\t\t\t\t\t<Vertical\r\n\t\t\t\t\t\t\t\t\tid=\"YSlider\"\r\n\t\t\t\t\t\t\t\t\tcallbackFromParent={this.updateRows}\r\n\t\t\t\t\t\t\t\t></Vertical>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</Col>\r\n\t\t\t\t\t\t<Col xs=\"11\">\r\n\t\t\t\t\t\t\t<div className=\"grid\">\r\n\t\t\t\t\t\t\t\t{grid.map((row, rowIdx) => {\r\n\t\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t\t<Row key={rowIdx}>\r\n\t\t\t\t\t\t\t\t\t\t\t{row.map((node, nodeIdx) => {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst { row, col, isFinish, isStart, isWall } = node;\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Node\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey={nodeIdx}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcol={col}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisFinish={isFinish}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmouseIsPressed={mouseIsPressed}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) =>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseDown(row, col)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseEnter(row, col)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trow={row}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t></Node>\r\n\t\t\t\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t\t\t\t\t</Row>\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</Col>\r\n\t\t\t\t\t</Row>\r\n\t\t\t\t</Container>\r\n\t\t\t</>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n\tconst grid = [];\r\n\r\n\tfor (let row = 0; row < totalRows; row++) {\r\n\t\tconst currentRow = [];\r\n\t\tfor (let col = 0; col < totalCols; col++) {\r\n\t\t\tcurrentRow.push(createNode(col, row));\r\n\t\t}\r\n\t\tgrid.push(currentRow);\r\n\t}\r\n\treturn grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n\treturn {\r\n\t\tcol,\r\n\t\trow,\r\n\t\tisStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n\t\tisFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n\t\tdistance: Infinity,\r\n\t\tdistanceToEnd: Infinity,\r\n\t\tisVisited: false,\r\n\t\tisWall: false,\r\n\t\tpreviousNode: null\r\n\t};\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n\tconst newGrid = grid.slice();\r\n\tconst node = newGrid[row][col];\r\n\tconst newNode = {\r\n\t\t...node,\r\n\t\tisWall: !node.isWall\r\n\t};\r\n\tnewGrid[row][col] = newNode;\r\n\treturn newGrid;\r\n};\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nfunction App() {\r\n\treturn (\r\n\t\t<div className=\"App\">\r\n\t\t\t<PathfindingVisualizer></PathfindingVisualizer>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}